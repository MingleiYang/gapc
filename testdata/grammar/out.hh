
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     gapc
// 
//   GAP-C call:
//     gapc -p affine * pretty --backtrace --cyk affinelocsim.gap 
// 
// 


#ifndef out_hh
#define out_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

struct spair {
  String first;
  String second;
  bool empty_;
  spair() : empty_(false) {}

};

inline std::ostream &operator<<(std::ostream &o, const spair &tuple) {
  o << '('   << tuple.first   << ", " << tuple.second
   << ')' ;
  return o;
}

inline void empty(spair &e) {e.empty_ = true; }
inline bool isEmpty(const spair &e) { return e.empty_; }
#include <rtlib/subopt.hh>

#include <rtlib/generic_opts.hh>
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

class out {

  public:
Basic_Sequence<char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

int int_zero;

class alignment_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<int > array;
unsigned int t_0_n;
int zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

alignment_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
}
int &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, int e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
}


};
alignment_table_t alignment_table;


class xDel_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<int > array;
unsigned int t_0_n;
int zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

xDel_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
}
int &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, int e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
}


};
xDel_table_t xDel_table;


class xIns_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<int > array;
unsigned int t_0_n;
int zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

xIns_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
}
int &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, int e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
}


};
xIns_table_t xIns_table;



void init(const gapc::Opts &opts)
{
const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
  alignment_table.init( t_0_seq.size(), "alignment_table");
  xDel_table.init( t_0_seq.size(), "xDel_table");
  xIns_table.init( t_0_seq.size(), "xIns_table");
empty(int_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
}

  private:
    int &  nt_alignment(unsigned int t_0_i, unsigned int t_0_j);
    void nt_tabulate_alignment(unsigned int t_0_i, unsigned int t_0_j);
    int nt_skipL(unsigned int t_0_i, unsigned int t_0_j);
    int nt_skipR(unsigned int t_0_j);
    int &  nt_xDel(unsigned int t_0_i, unsigned int t_0_j);
    void nt_tabulate_xDel(unsigned int t_0_i, unsigned int t_0_j);
    int &  nt_xIns(unsigned int t_0_i, unsigned int t_0_j);
    void nt_tabulate_xIns(unsigned int t_0_i, unsigned int t_0_j);

    int del(char a, int m);
    int delx(char a, int m);
    int h(int l);
    int ins(int m, char b);
    int insx(int m, char b);
    int match(char a, int m, char b);
    int nil(int l);
    int sl(char a, int m);
    int sr(int m, char b);


 public:
   void cyk();

 public:
   int run()
{
  return nt_skipR(t_0_right_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      alignment_table.print_stats(o, "alignment_table");
      xDel_table.print_stats(o, "xDel_table");
      xIns_table.print_stats(o, "xIns_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_del : Backtrace<Value, pos_int> {
      char arg_a;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;

Backtrace_del(char arg_a_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_)
 : arg_a(arg_a_), arg_m(arg_m_)
{}

~Backtrace_del()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair del(char a, spair m)
      {
#line 33 ""
        spair r;
        append( r.first, a);
        append( r.first, m.first);
        append( r.second, '=');
        append( r.second, m.second);
        return r;
#line 281 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = del(arg_a, arg_m_elem);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = del(arg_a, arg_m_elem);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_delx : Backtrace<Value, pos_int> {
      char arg_a;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;

Backtrace_delx(char arg_a_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_)
 : arg_a(arg_a_), arg_m(arg_m_)
{}

~Backtrace_delx()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair delx(char a, spair m)
      {
#line 53 ""
        spair r;
        append( r.first, a);
        append( r.first, m.first);
        append( r.second, '-');
        append( r.second, m.second);
        return r;
#line 341 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = delx(arg_a, arg_m_elem);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = delx(arg_a, arg_m_elem);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ins : Backtrace<Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;
      char arg_b;

Backtrace_ins(intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_, char arg_b_)
 : arg_m(arg_m_), arg_b(arg_b_)
{}

~Backtrace_ins()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair ins(spair m, char b)
      {
#line 43 ""
        spair r;
        append( r.first, '=');
        append( r.first, m.first);
        append( r.second, b);
        append( r.second, m.second);
        return r;
#line 401 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = ins(arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = ins(arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_insx : Backtrace<Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;
      char arg_b;

Backtrace_insx(intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_, char arg_b_)
 : arg_m(arg_m_), arg_b(arg_b_)
{}

~Backtrace_insx()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair insx(spair m, char b)
      {
#line 63 ""
        spair r;
        append( r.first, '-');
        append( r.first, m.first);
        append( r.second, b);
        append( r.second, m.second);
        return r;
#line 461 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = insx(arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = insx(arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_match : Backtrace<Value, pos_int> {
      char arg_a;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;
      char arg_b;

Backtrace_match(char arg_a_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_, char arg_b_)
 : arg_a(arg_a_), arg_m(arg_m_), arg_b(arg_b_)
{}

~Backtrace_match()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair match(char a, spair m, char b)
      {
#line 23 ""
        spair r;
        append( r.first, a);
        append( r.first, m.first);
        append( r.second, b);
        append( r.second, m.second);
        return r;
#line 522 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = match(arg_a, arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = match(arg_a, arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace<Value, pos_int> {
      int arg_l;

Backtrace_nil(int arg_l_)
 : arg_l(arg_l_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair nil(int l)
      {
#line 74 ""
        spair r;
        return r;
#line 576 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        spair ret = nil(arg_l);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sl : Backtrace<Value, pos_int> {
      char arg_a;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;

Backtrace_sl(char arg_a_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_)
 : arg_a(arg_a_), arg_m(arg_m_)
{}

~Backtrace_sl()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair sl(char a, spair m)
      {
#line 80 ""
        return m;
#line 611 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = sl(arg_a, arg_m_elem);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = sl(arg_a, arg_m_elem);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace<Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_m;
      char arg_b;

Backtrace_sr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_, char arg_b_)
 : arg_m(arg_m_), arg_b(arg_b_)
{}

~Backtrace_sr()
{
erase(arg_m);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      spair sr(spair m, char b)
      {
#line 85 ""
        return m;
#line 666 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_m_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_m);
        if (!arg_m_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = arg_m;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = sr(arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_m_bt_itr = arg_m_t->begin(); arg_m_bt_itr != arg_m_t->end(); ++arg_m_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_m_bt = *arg_m_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_m_elist = evaluate(arg_m_bt);
          for (typename Eval_List<Value>::iterator arg_m_elem_itr = arg_m_elist->begin(); arg_m_elem_itr != arg_m_elist->end(); ++arg_m_elem_itr) {
            spair arg_m_elem = *arg_m_elem_itr;
            spair ret = sr(arg_m_elem, arg_b);
            push_back( answer, ret);
          }
          erase( arg_m_elist);
        }
        erase( arg_m);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int>
struct Backtrace_nt_skipR : public Backtrace<Value, pos_int> {
      Klass *klass;
      pos_int t_0_j;

intrusive_ptr<Backtrace<Value, pos_int> > proxy;

      Backtrace_nt_skipR(Klass *klass_, pos_int t_0_j_) : klass(klass_), t_0_j(t_0_j_), proxy(0) {}
~Backtrace_nt_skipR() { erase(proxy); }
      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
      {
        return klass->bt_nt_skipR(t_0_j);
      }

intrusive_ptr<Eval_List<Value> > eval() { proxy = backtrack(); return proxy->eval(); }};

template <typename Klass, typename Value, typename pos_int>
struct Backtrace_nt_skipL : public Backtrace<Value, pos_int> {
      Klass *klass;
      pos_int t_0_i;
      pos_int t_0_j;

intrusive_ptr<Backtrace<Value, pos_int> > proxy;

      Backtrace_nt_skipL(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_) : klass(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_), proxy(0) {}
~Backtrace_nt_skipL() { erase(proxy); }
      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
      {
        return klass->bt_nt_skipL(t_0_i, t_0_j);
      }

intrusive_ptr<Eval_List<Value> > eval() { proxy = backtrack(); return proxy->eval(); }};

template <typename Klass, typename Value, typename pos_int>
struct Backtrace_nt_alignment : public Backtrace<Value, pos_int> {
      Klass *klass;
      pos_int t_0_i;
      pos_int t_0_j;

intrusive_ptr<Backtrace<Value, pos_int> > proxy;

      Backtrace_nt_alignment(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_) : klass(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_), proxy(0) {}
~Backtrace_nt_alignment() { erase(proxy); }
      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
      {
        return klass->bt_nt_alignment(t_0_i, t_0_j);
      }

intrusive_ptr<Eval_List<Value> > eval() { proxy = backtrack(); return proxy->eval(); }};

template <typename Klass, typename Value, typename pos_int>
struct Backtrace_nt_xDel : public Backtrace<Value, pos_int> {
      Klass *klass;
      pos_int t_0_i;
      pos_int t_0_j;

intrusive_ptr<Backtrace<Value, pos_int> > proxy;

      Backtrace_nt_xDel(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_) : klass(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_), proxy(0) {}
~Backtrace_nt_xDel() { erase(proxy); }
      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
      {
        return klass->bt_nt_xDel(t_0_i, t_0_j);
      }

intrusive_ptr<Eval_List<Value> > eval() { proxy = backtrack(); return proxy->eval(); }};

template <typename Klass, typename Value, typename pos_int>
struct Backtrace_nt_xIns : public Backtrace<Value, pos_int> {
      Klass *klass;
      pos_int t_0_i;
      pos_int t_0_j;

intrusive_ptr<Backtrace<Value, pos_int> > proxy;

      Backtrace_nt_xIns(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_) : klass(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_), proxy(0) {}
~Backtrace_nt_xIns() { erase(proxy); }
      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
      {
        return klass->bt_nt_xIns(t_0_i, t_0_j);
      }

intrusive_ptr<Eval_List<Value> > eval() { proxy = backtrack(); return proxy->eval(); }};

    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > bt_proxy_nt_skipR(unsigned int t_0_j);
    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > bt_proxy_nt_skipL(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > bt_proxy_nt_alignment(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > bt_proxy_nt_xDel(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > bt_proxy_nt_xIns(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<spair, unsigned int> >  bt_nt_alignment(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<spair, unsigned int> >  bt_nt_skipL(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<spair, unsigned int> >  bt_nt_skipR(unsigned int t_0_j);
    intrusive_ptr<Backtrace<spair, unsigned int> >  bt_nt_xDel(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<spair, unsigned int> >  bt_nt_xIns(unsigned int t_0_i, unsigned int t_0_j);

    intrusive_ptr<Backtrace<spair, unsigned int> >  del_bt_r(char param_0, intrusive_ptr<Backtrace<spair, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<spair, unsigned int> >  delx_bt_r(char param_0, intrusive_ptr<Backtrace<spair, unsigned int> >  param_1);
    List_Ref<intrusive_ptr<Backtrace<spair, unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<spair, unsigned int> > > param_0);
    intrusive_ptr<Backtrace<spair, unsigned int> >  ins_bt_r(intrusive_ptr<Backtrace<spair, unsigned int> >  param_0, char param_1);
    intrusive_ptr<Backtrace<spair, unsigned int> >  insx_bt_r(intrusive_ptr<Backtrace<spair, unsigned int> >  param_0, char param_1);
    intrusive_ptr<Backtrace<spair, unsigned int> >  match_bt_r(char param_0, intrusive_ptr<Backtrace<spair, unsigned int> >  param_1, char param_2);
    intrusive_ptr<Backtrace<spair, unsigned int> >  nil_bt_r(int param_0);
    intrusive_ptr<Backtrace<spair, unsigned int> >  sl_bt_r(char param_0, intrusive_ptr<Backtrace<spair, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<spair, unsigned int> >  sr_bt_r(intrusive_ptr<Backtrace<spair, unsigned int> >  param_0, char param_1);


    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  del_bt(char p_a, const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  delx_bt(char p_a, const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m);
    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > h_bt(List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > l, int &  left);
    List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > h_bt(List_Ref<std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > > l);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  ins_bt(const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m, char p_b);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  insx_bt(const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m, char p_b);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  match_bt(char p_a, const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m, char p_b);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  nil_bt(int p_l);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  sl_bt(char p_a, const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m);
    std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > >  sr_bt(const std::pair<int, intrusive_ptr<Backtrace<spair, unsigned int> > > & p_m, char p_b);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<spair, unsigned int> >  backtrack(unsigned int t_0_j)
{
  return bt_nt_skipR(t_0_j);
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<spair, unsigned int> >  bt = backtrack(t_0_right_most);
if (!bt)
return;
intrusive_ptr<Eval_List<spair> > elist = bt->eval();
elist->print(out, value);
erase(elist);
erase(bt);

}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef out class_name;
  typedef int return_type;
}
#endif

#endif

