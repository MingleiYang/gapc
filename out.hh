
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     gapc
// 
//   GAP-C call:
//     gapc -i timecalcppenum testdata/grammar/elm.gap 
// 
// 


#ifndef out_hh
#define out_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

#include <rtlib/subopt.hh>

#include <rtlib/generic_opts.hh>
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

class out {

  public:
Basic_Sequence<char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > LBBBint_firstG_int_secondG_E_firstG_string_secondG_E_firstG_Rope_secondG_EM_zero;
std::pair<std::pair<std::pair<int, int> , String> , Rope>  BBBint_firstG_int_secondG_E_firstG_string_secondG_E_firstG_Rope_secondG_E_zero;
char char_zero;

class formula_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

formula_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 1))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 1))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 1))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
formula_table_t formula_table;


class times_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<char > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
char zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

times_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if ((((t_0_j - t_0_i) < 1) || ((t_0_j - t_0_i) > 1)))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
char &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((((t_0_j - t_0_i) < 1) || ((t_0_j - t_0_i) > 1)))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, char e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((((t_0_j - t_0_i) < 1) || ((t_0_j - t_0_i) > 1)))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
times_table_t times_table;



void init(const gapc::Opts &opts)
{
const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
  formula_table.init( t_0_seq.size(), "formula_table");
  times_table.init( t_0_seq.size(), "times_table");
empty(LBBBint_firstG_int_secondG_E_firstG_string_secondG_E_firstG_Rope_secondG_EM_zero);
empty(BBBint_firstG_int_secondG_E_firstG_string_secondG_E_firstG_Rope_secondG_E_zero);
empty(char_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
}

  private:
    List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > &  nt_formula(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<std::pair<std::pair<int, int> , String> , Rope>  nt_number(unsigned int t_0_i, unsigned int t_0_j);
    char nt_plus(unsigned int t_0_i, unsigned int t_0_j);
    char &  nt_times(unsigned int t_0_i, unsigned int t_0_j);

    std::pair<std::pair<std::pair<int, int> , String> , Rope>  add(const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_i, char p_p_p_c, const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_j);
    std::pair<std::pair<std::pair<int, int> , String> , Rope>  f(int p_p_p_i);
    List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > h(List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > i);
template <typename Iterator>
    List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > h(std::pair<Iterator, Iterator> i)
;
    std::pair<std::pair<std::pair<int, int> , String> , Rope>  mult(const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_i, char p_p_p_c, const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_j);


    std::pair<std::pair<int, int> , String>  add_l(const std::pair<std::pair<int, int> , String> & p_p_i, char p_p_c, const std::pair<std::pair<int, int> , String> & p_p_j);
    std::pair<std::pair<int, int> , String>  f_l(int p_p_i);
    List_Ref<std::pair<std::pair<int, int> , String> > h_l(List_Ref<std::pair<std::pair<int, int> , String> > i);
template <typename Iterator>
    List_Ref<std::pair<std::pair<int, int> , String> > h_l(std::pair<Iterator, Iterator> i)
;
    std::pair<std::pair<int, int> , String>  mult_l(const std::pair<std::pair<int, int> , String> & p_p_i, char p_p_c, const std::pair<std::pair<int, int> , String> & p_p_j);


    std::pair<int, int>  add_l_l(const std::pair<int, int> & p_i, char p_c, const std::pair<int, int> & p_j);
    std::pair<int, int>  f_l_l(int p_i);
    List_Ref<std::pair<int, int> > h_l_l(List_Ref<std::pair<int, int> > i);
template <typename Iterator>
    List_Ref<std::pair<int, int> > h_l_l(std::pair<Iterator, Iterator> i)
;
    std::pair<int, int>  mult_l_l(const std::pair<int, int> & p_i, char p_c, const std::pair<int, int> & p_j);


    int add_l_l_l(int i, char c, int j);
    int f_l_l_l(int i);
    int h_l_l_l(List_Ref<int> i);
template <typename Iterator>
    int h_l_l_l(std::pair<Iterator, Iterator> i)
;
    int mult_l_l_l(int i, char c, int j);


    int add_l_l_r(int i, char c, int j);
    int f_l_l_r(int i);
    List_Ref<int> h_l_l_r(List_Ref<int> i);
    int mult_l_l_r(int i, char c, int j);


    String add_l_r(const String & i, char c, const String & j);
    String f_l_r(int i);
    List_Ref<String> h_l_r(List_Ref<String> i);
    String mult_l_r(const String & i, char c, const String & j);


    Rope add_r(const Rope & param_0, char param_1, const Rope & param_2);
    Rope f_r(int param_0);
    List_Ref<Rope> h_r(List_Ref<Rope> param_0);
    Rope mult_r(const Rope & param_0, char param_1, const Rope & param_2);


 public:
   void cyk();

 public:
   List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > &  run()
{
  return nt_formula(t_0_left_most, t_0_right_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      formula_table.print_stats(o, "formula_table");
      times_table.print_stats(o, "times_table");
#endif
}

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
if (isEmpty(res))
  out << "[]\n";
else
  out << res << '\n';

}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef out class_name;
  typedef List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > &  return_type;
}
#endif

#endif

