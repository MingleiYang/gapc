/* {{{

    This file is part of gapc (GAPC - Grammars, Algebras, Products - Compiler;
      a system to compile algebraic dynamic programming programs)

    Copyright (C) 2008-2011  Georg Sauthoff
         email: gsauthof@techfak.uni-bielefeld.de or gsauthof@sdf.lonestar.org

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

}}} */

#include "cfg_pretty_print.hh"

#include <string>
#include <iostream>
#include <list>
#include <sstream>
#include <iomanip>
#include <cassert>

#include "../log.hh"


Printer::CFGPrettyPrint::CFGPrettyPrint(std::ostream &oStream)
  : oStream(oStream), taggedPrintMode(false) {
}


void Printer::CFGPrettyPrint::setCommandLineCall(std::string* commandLineCall) {
  this->commandLineCall = commandLineCall;
}


void Printer::CFGPrettyPrint::prettyPrint(CFG::CFG *cfg) {
  // print some header containing information about the compiler
  // call that generated the grammar output
  oStream << "/* This grammar was generated by gapc with the command   */"
    << std::endl;
  oStream << "/*                                                       */"
    << std::endl;
  oStream << "/* " << *this->commandLineCall << " */" << std::endl;
  oStream << "/*                                                       */"
    << std::endl;
  oStream << "/* This file can be used as direct input to the tool     */"
    << std::endl;
  oStream << "/* found at http://www.brics.dk/grammar/, or by using    */"
    << std::endl;
  oStream << "/* the online version at                                 */"
    << std::endl;
  oStream << "/* http://services.brics.dk/java/grammar/demo.html       */"
    << std::endl;
  oStream << std::endl;
  oStream << std::endl;


  // Start with all regular expressions.
  std::list<CFG::RegularExpression*> regexList = cfg->getRegularExpressions();
  // if no expressions are in the list, omit the banner
  if (regexList.begin() != regexList.end()) {
    oStream << "/* Definitions of regular expressions                    */"
      << std::endl;
    oStream << std::endl;
  }
  for (std::list<CFG::RegularExpression*>::iterator i = regexList.begin();
       i != regexList.end(); ++i) {
    ppRegularExpressionRule(*i);
  }

  oStream << std::endl;
  oStream << std::endl;
  oStream << "/* The grammar. Note, the first rule marks the axiom.    */"
    << std::endl;
  oStream << std::endl;
  // Then print out the grammar.
  std::list<CFG::GrammarProduction*> productions = cfg->getProductions();
  for (std::list<CFG::GrammarProduction*>::iterator i = productions.begin();
       i != productions.end(); ++i) {
    ppGrammarProduction(*i);
  }

  // add a last end-line
  oStream << std::endl;
}


void Printer::CFGPrettyPrint::ppGrammarProduction(
  CFG::GrammarProduction *prod) {
  // Create the padding string which length is the same as that
  // of the grammar production's name.
  std::string* padding = new std::string("");
  std::stringstream strstrm;
  strstrm << std::setw(prod->lhs->getName()->length()) << " ";
  padding = new std::string(strstrm.str());

  // first pring the left-hand-side of the production...
  ppNonTerminal(prod->lhs);
  oStream << " : ";
  // ...then the right-hand-side
  ppProductionAlternative(padding, prod->rhs);
  oStream << std::endl;
}


void Printer::CFGPrettyPrint::ppBase(std::string *padding, CFG::Base *b) {
  // check parameters first
  assert(b != NULL);
  // then do some work
  switch (b->getType()) {
    case CFG::BASE_WRAPPER: {
      if (taggedPrintMode) std::cout << "<WRAPPER>";
      ppBaseWrapper(padding, (CFG::BaseWrapper*)b);
      break;
    }
    case CFG::SNAPSHOT: {
      if (taggedPrintMode) std::cout << "<SNAPSHOT>";
      ppSnapshot(padding, (CFG::Snapshot*)b);
      break;
    }
    case CFG::EPSILON: {
      if (taggedPrintMode) std::cout << "<EPSILON>";
      ppEpsilon((CFG::Epsilon*)b);
      break;
    }
    case CFG::TERMINAL: {
      if (taggedPrintMode) std::cout << "<TERMINAL>";
      ppTerminal((CFG::Terminal*)b);
      break;
    }
    case CFG::NONTERMINAL: {
      if (taggedPrintMode) std::cout << "<NONTERMINAL>";
      ppNonTerminal((CFG::NonTerminal*)b);
      break;
    }
    case CFG::REGULAR_EXPRESSION: {
      if (taggedPrintMode) std::cout << "<REGULAR_EXPRESSION>";
      ppRegExpName((CFG::RegularExpression*)b);
      break;
    }
    case CFG::PRODUCTION_SEQUENCE: {
      if (taggedPrintMode) std::cout << "<PRODUCTION_SEQUENCE>";
      ppProductionSequence(padding, (CFG::ProductionSequence*)b);
      break;
    }
    case CFG::PRODUCTION_ALTERNATIVE: {
      if (taggedPrintMode) std::cout << "<PRODUCTION_ALTERNATIVE>";
      ppProductionAlternative(padding, (CFG::ProductionAlternative*)b);
      break;
    }
    case CFG::BASE:
    default: {
      throw LogError("gap-00487: Internal: Unandled CFG node type");
    }
  }
}


void Printer::CFGPrettyPrint::ppBaseWrapper(
  std::string* padding, CFG::BaseWrapper* w) {
  ppBase(padding, w->getWrappedBase());
}


void Printer::CFGPrettyPrint::ppSnapshot(
  std::string *padding, CFG::Snapshot* s) {
  //
  oStream << "[";
  ppBase(padding, s->getOriginal());
  oStream << " (+) ";
  ppBase(padding, s->getChanges());
  oStream << "]";
}


void Printer::CFGPrettyPrint::ppEpsilon(CFG::Epsilon *e) {
  // The epsilon must be omitted in the output according to
  // the target file format, thus:
  // oStream << "<epsilon>";
  oStream << "/* empty */";
}


void Printer::CFGPrettyPrint::ppTerminal(CFG::Terminal *t) {
  oStream << "\"" << *t->getValue() << "\"";
}


void Printer::CFGPrettyPrint::ppNonTerminal(CFG::NonTerminal *nt) {
  oStream << *nt->getName();
}


void Printer::CFGPrettyPrint::ppProductionSequence(
  std::string *padding, CFG::ProductionSequence *seq) {
  bool firstRun = true;
  for (int i = 0; i < seq->getSize(); i++) {
    if (!firstRun) {
      oStream << " ";
    }
    ppBase(padding, seq->elementAt(i));
    firstRun = false;
  }
}


void Printer::CFGPrettyPrint::ppProductionAlternative(
  std::string *padding, CFG::ProductionAlternative *alt) {
  bool firstRun = true;
  for (CFG::ProductionAlternative::iterator i = alt->begin();
       i != alt->end(); i++) {
    if (!firstRun) {
      if (padding != NULL) {
        oStream << std::endl << *padding;
      }
      oStream << " | ";
    }
    ppBase(padding, *i);
    firstRun = false;
  }
}


void Printer::CFGPrettyPrint::ppRegularExpressionRule(
  CFG::RegularExpression* regexp) {
  // print the identifier first
  oStream << *regexp->getName() << " = " << *regexp->getExpression();
  CFG::Bounds* bounds = regexp->getBounds();
  if (bounds != NULL && (bounds->getLowerBound() != CFG::Bounds::UNDEFINED ||
      bounds->getUpperBound() != CFG::Bounds::UNDEFINED)) {
    oStream << "{";
    if (bounds->getLowerBound() != CFG::Bounds::UNDEFINED) {
      oStream << bounds->getLowerBound() << ",";
    }
    if (bounds->getUpperBound() != CFG::Bounds::UNDEFINED) {
      oStream << bounds->getUpperBound();
    }
    oStream << "}";
  }
  oStream << std::endl;
}


void Printer::CFGPrettyPrint::ppRegExpName(CFG::RegularExpression* regexp) {
  oStream << "<" << *regexp->getName() << ">";
}
