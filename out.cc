
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     gapc
// 
//   GAP-C call:
//     gapc -i timecalcppenum testdata/grammar/elm.gap 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "out.hh"

#include <rtlib/subopt.hh>

#include <rtlib/generic_opts.hh>
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > &  out::nt_formula(unsigned int t_0_i, unsigned int t_0_j)
{
  if (formula_table.is_tabulated(t_0_i, t_0_j))
    {
      return formula_table.get(t_0_i, t_0_j);
    }

  List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > answers;
  empty(answers);
  empty( answers);
  std::pair<std::pair<std::pair<int, int> , String> , Rope>  ret_0 = nt_number(t_0_i, t_0_j);
  if (is_not_empty(ret_0))
    {
      push_back_min_other( answers, ret_0);
    }


  if (((t_0_j - t_0_i) >= 3))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 1); (t_0_k_0 <= (t_0_j - 2)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > ret_4 = nt_formula((t_0_k_0 + 1), t_0_j);
        List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > a_2 = ret_4;
        if (is_not_empty(a_2))
        {
          char ret_3 = nt_plus(t_0_k_0, (t_0_k_0 + 1));
          char a_1 = ret_3;
          if (is_not_empty(a_1))
          {
            List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > ret_2 = nt_formula(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > a_0 = ret_2;
            if (is_not_empty(a_0))
              {
                for (List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                  std::pair<std::pair<std::pair<int, int> , String> , Rope>  x_0 = *x_0_itr;
                  for (List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                    std::pair<std::pair<std::pair<int, int> , String> , Rope>  x_2 = *x_2_itr;
                    std::pair<std::pair<std::pair<int, int> , String> , Rope>  ans = add(x_0, a_1, x_2);
                    push_back_min_other( answers, ans);
                  }
                }
              }

            erase( a_0);
          }

          erase( a_1);
        }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 3))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 1); (t_0_k_1 <= (t_0_j - 2)); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > ret_8 = nt_formula((t_0_k_1 + 1), t_0_j);
        List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > a_5 = ret_8;
        if (is_not_empty(a_5))
        {
          char ret_7 = nt_times(t_0_k_1, (t_0_k_1 + 1));
          char a_4 = ret_7;
          if (is_not_empty(a_4))
          {
            List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > ret_6 = nt_formula(t_0_i, t_0_k_1);
            List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > a_3 = ret_6;
            if (is_not_empty(a_3))
              {
                for (List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<std::pair<int, int> , String> , Rope>  x_3 = *x_3_itr;
                  for (List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                    std::pair<std::pair<std::pair<int, int> , String> , Rope>  x_5 = *x_5_itr;
                    std::pair<std::pair<std::pair<int, int> , String> , Rope>  ans = mult(x_3, a_4, x_5);
                    push_back_min_other( answers, ans);
                  }
                }
              }

            erase( a_3);
          }

          erase( a_4);
        }

        erase( a_5);
      }

    }

  List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > eval = h(answers);
  erase( answers);
  formula_table.set( t_0_i, t_0_j, eval);
  return formula_table.get(t_0_i, t_0_j);
}

std::pair<std::pair<std::pair<int, int> , String> , Rope>  out::nt_number(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 1))
    {
      return BBBint_firstG_int_secondG_E_firstG_string_secondG_E_firstG_Rope_secondG_E_zero;
    }

  std::pair<std::pair<std::pair<int, int> , String> , Rope>  answers;
  empty( answers);
  std::pair<std::pair<std::pair<int, int> , String> , Rope>  ret_0;
  if (((t_0_j - t_0_i) >= 1))
  {
    int ret_1 = INT(t_0_seq, t_0_i, t_0_j);
    int a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        ret_0 = f(a_0);
      }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

char out::nt_plus(unsigned int t_0_i, unsigned int t_0_j)
{
  if ((((t_0_j - t_0_i) < 1) || ((t_0_j - t_0_i) > 1)))
    {
      return char_zero;
    }

  char answers;
  empty( answers);
  char ret_0;
  if ((((t_0_j - t_0_i) >= 1) && ((t_0_j - t_0_i) <= 1)))
    {
      ret_0 = CHAR(t_0_seq, t_0_i, t_0_j, '+');
    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

char &  out::nt_times(unsigned int t_0_i, unsigned int t_0_j)
{
  if (times_table.is_tabulated(t_0_i, t_0_j))
    {
      return times_table.get(t_0_i, t_0_j);
    }

  char answers;
  empty( answers);
  char ret_0;
  if ((((t_0_j - t_0_i) >= 1) && ((t_0_j - t_0_i) <= 1)))
    {
      ret_0 = CHAR(t_0_seq, t_0_i, t_0_j, '*');
    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  times_table.set( t_0_i, t_0_j, answers);
  return times_table.get(t_0_i, t_0_j);
}


std::pair<std::pair<std::pair<int, int> , String> , Rope>  out::add(const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_i, char p_p_p_c, const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_j)
{
  std::pair<std::pair<int, int> , String>  l_0 = p_p_p_i.first;
  char l_1 = p_p_p_c;
  std::pair<std::pair<int, int> , String>  l_2 = p_p_p_j.first;
  Rope r_0 = p_p_p_i.second;
  char r_1 = p_p_p_c;
  Rope r_2 = p_p_p_j.second;
  std::pair<std::pair<int, int> , String>  ret_left = add_l(l_0, l_1, l_2);
  Rope ret_right = add_r(r_0, r_1, r_2);
  std::pair<std::pair<std::pair<int, int> , String> , Rope>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<std::pair<int, int> , String> , Rope>  out::f(int p_p_p_i)
{
  int l_0 = p_p_p_i;
  int r_0 = p_p_p_i;
  std::pair<std::pair<int, int> , String>  ret_left = f_l(l_0);
  Rope ret_right = f_r(r_0);
  std::pair<std::pair<std::pair<int, int> , String> , Rope>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > out::h(List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > i)
{
  std::pair<List<std::pair<std::pair<std::pair<int, int> , String> , Rope> >::iterator, List<std::pair<std::pair<std::pair<int, int> , String> , Rope> >::iterator> range = get_range(i);
  return h(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > out::h(std::pair<Iterator, Iterator> i)

{
  List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > answers;
  empty(answers);
  empty( answers);
  std::pair<Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> >  ,Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> > >  left = splice_left(i);
  List_Ref<std::pair<std::pair<int, int> , String> > left_answers = h_l(left);
  if (isEmpty(left_answers))
  {
    List_Ref<std::pair<std::pair<std::pair<int, int> , String> , Rope> > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (List_Ref<std::pair<std::pair<int, int> , String> >::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
        {
          push_back_min_other( answers, (*tupel));
        }

    }
  }
  return answers;
}

std::pair<std::pair<std::pair<int, int> , String> , Rope>  out::mult(const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_i, char p_p_p_c, const std::pair<std::pair<std::pair<int, int> , String> , Rope> & p_p_p_j)
{
  std::pair<std::pair<int, int> , String>  l_0 = p_p_p_i.first;
  char l_1 = p_p_p_c;
  std::pair<std::pair<int, int> , String>  l_2 = p_p_p_j.first;
  Rope r_0 = p_p_p_i.second;
  char r_1 = p_p_p_c;
  Rope r_2 = p_p_p_j.second;
  std::pair<std::pair<int, int> , String>  ret_left = mult_l(l_0, l_1, l_2);
  Rope ret_right = mult_r(r_0, r_1, r_2);
  std::pair<std::pair<std::pair<int, int> , String> , Rope>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



std::pair<std::pair<int, int> , String>  out::add_l(const std::pair<std::pair<int, int> , String> & p_p_i, char p_p_c, const std::pair<std::pair<int, int> , String> & p_p_j)
{
  std::pair<int, int>  l_0 = p_p_i.first;
  char l_1 = p_p_c;
  std::pair<int, int>  l_2 = p_p_j.first;
  String r_0 = p_p_i.second;
  char r_1 = p_p_c;
  String r_2 = p_p_j.second;
  std::pair<int, int>  ret_left = add_l_l(l_0, l_1, l_2);
  String ret_right = add_l_r(r_0, r_1, r_2);
  std::pair<std::pair<int, int> , String>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<int, int> , String>  out::f_l(int p_p_i)
{
  int l_0 = p_p_i;
  int r_0 = p_p_i;
  std::pair<int, int>  ret_left = f_l_l(l_0);
  String ret_right = f_l_r(r_0);
  std::pair<std::pair<int, int> , String>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

List_Ref<std::pair<std::pair<int, int> , String> > out::h_l(List_Ref<std::pair<std::pair<int, int> , String> > i)
{
  std::pair<List<std::pair<std::pair<int, int> , String> >::iterator, List<std::pair<std::pair<int, int> , String> >::iterator> range = get_range(i);
  return h_l(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<int, int> , String> > out::h_l(std::pair<Iterator, Iterator> i)

{
  List_Ref<std::pair<std::pair<int, int> , String> > answers;
  empty(answers);
  empty( answers);
  std::pair<Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> >  ,Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> > >  left = splice_left(i);
  List_Ref<std::pair<int, int> > left_answers = h_l_l(left);
  if (isEmpty(left_answers))
  {
    List_Ref<std::pair<std::pair<int, int> , String> > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (List_Ref<std::pair<int, int> >::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
        {
          push_back( answers, (*tupel));
        }

    }
  }
  return answers;
}

std::pair<std::pair<int, int> , String>  out::mult_l(const std::pair<std::pair<int, int> , String> & p_p_i, char p_p_c, const std::pair<std::pair<int, int> , String> & p_p_j)
{
  std::pair<int, int>  l_0 = p_p_i.first;
  char l_1 = p_p_c;
  std::pair<int, int>  l_2 = p_p_j.first;
  String r_0 = p_p_i.second;
  char r_1 = p_p_c;
  String r_2 = p_p_j.second;
  std::pair<int, int>  ret_left = mult_l_l(l_0, l_1, l_2);
  String ret_right = mult_l_r(r_0, r_1, r_2);
  std::pair<std::pair<int, int> , String>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



std::pair<int, int>  out::add_l_l(const std::pair<int, int> & p_i, char p_c, const std::pair<int, int> & p_j)
{
  int l_0 = p_i.first;
  char l_1 = p_c;
  int l_2 = p_j.first;
  int r_0 = p_i.second;
  char r_1 = p_c;
  int r_2 = p_j.second;
  int ret_left = add_l_l_l(l_0, l_1, l_2);
  int ret_right = add_l_l_r(r_0, r_1, r_2);
  std::pair<int, int>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<int, int>  out::f_l_l(int p_i)
{
  int l_0 = p_i;
  int r_0 = p_i;
  int ret_left = f_l_l_l(l_0);
  int ret_right = f_l_l_r(r_0);
  std::pair<int, int>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

List_Ref<std::pair<int, int> > out::h_l_l(List_Ref<std::pair<int, int> > i)
{
  std::pair<List<std::pair<int, int> >::iterator, List<std::pair<int, int> >::iterator> range = get_range(i);
  return h_l_l(range);
}

template <typename Iterator>
List_Ref<std::pair<int, int> > out::h_l_l(std::pair<Iterator, Iterator> i)

{
  List_Ref<std::pair<int, int> > answers;
  empty(answers);
  empty( answers);
  std::pair<Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> >  ,Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> > >  left = splice_left(i);
  int left_answers = h_l_l_l(left);
  if (isEmpty(left_answers))
  {
    List_Ref<std::pair<int, int> > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  int elem = left_answers;
  for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
    if (((*tupel).first == elem))
      {
        push_back( answers, (*tupel));
      }

  }
  return answers;
}

std::pair<int, int>  out::mult_l_l(const std::pair<int, int> & p_i, char p_c, const std::pair<int, int> & p_j)
{
  int l_0 = p_i.first;
  char l_1 = p_c;
  int l_2 = p_j.first;
  int r_0 = p_i.second;
  char r_1 = p_c;
  int r_2 = p_j.second;
  int ret_left = mult_l_l_l(l_0, l_1, l_2);
  int ret_right = mult_l_l_r(r_0, r_1, r_2);
  std::pair<int, int>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



int out::add_l_l_l(int i, char c, int j)
{
#line 74 "testdata/grammar/elm.gap"
  if ((i > j))
    {
      return (i + 2);
    }

  return (j + 2);
#line 461 "out.cc"
}

int out::f_l_l_l(int i)
{
#line 70 "testdata/grammar/elm.gap"
  return 0;
#line 468 "out.cc"
}

int out::h_l_l_l(List_Ref<int> i)
{
  std::pair<List<int>::iterator, List<int>::iterator> range = get_range(i);
  return h_l_l_l(range);
}

template <typename Iterator>
int out::h_l_l_l(std::pair<Iterator, Iterator> i)

{
#line 88 "testdata/grammar/elm.gap"
  return minimum(i);
#line 483 "out.cc"
}

int out::mult_l_l_l(int i, char c, int j)
{
#line 81 "testdata/grammar/elm.gap"
  if ((i > j))
    {
      return (i + 5);
    }

  return (j + 5);
#line 495 "out.cc"
}



int out::add_l_l_r(int i, char c, int j)
{
#line 41 "testdata/grammar/elm.gap"
  return (i + j);
#line 504 "out.cc"
}

int out::f_l_l_r(int i)
{
#line 37 "testdata/grammar/elm.gap"
  return i;
#line 511 "out.cc"
}

List_Ref<int> out::h_l_l_r(List_Ref<int> i)
{
#line 64 "testdata/grammar/elm.gap"
  return i;
#line 518 "out.cc"
}

int out::mult_l_l_r(int i, char c, int j)
{
#line 46 "testdata/grammar/elm.gap"
  return (i * j);
#line 525 "out.cc"
}



String out::add_l_r(const String & i, char c, const String & j)
{
#line 102 "testdata/grammar/elm.gap"
  String r;
  append( r, '(');
  append( r, i);
  append( r, c);
  append( r, j);
  append( r, ')');
  return r;
#line 540 "out.cc"
}

String out::f_l_r(int i)
{
#line 95 "testdata/grammar/elm.gap"
  String r;
  append( r, i);
  return r;
#line 549 "out.cc"
}

List_Ref<String> out::h_l_r(List_Ref<String> i)
{
#line 124 "testdata/grammar/elm.gap"
  return i;
#line 556 "out.cc"
}

String out::mult_l_r(const String & i, char c, const String & j)
{
#line 113 "testdata/grammar/elm.gap"
  String r;
  append( r, '(');
  append( r, i);
  append( r, c);
  append( r, j);
  append( r, ')');
  return r;
#line 569 "out.cc"
}



Rope out::add_r(const Rope & param_0, char param_1, const Rope & param_2)
{
  Rope ret;
  append( ret, "add(", 4);
  append( ret, ' ');
  append( ret, param_0);
  append( ret, ' ');
  append( ret, param_1);
  append( ret, ' ');
  append( ret, param_2);
  append( ret, ' ');
  append( ret, ')');
  return ret;
}

Rope out::f_r(int param_0)
{
  Rope ret;
  append( ret, "f(", 2);
  append( ret, ' ');
  append( ret, param_0);
  append( ret, ' ');
  append( ret, ')');
  return ret;
}

List_Ref<Rope> out::h_r(List_Ref<Rope> param_0)
{
  return param_0;
}

Rope out::mult_r(const Rope & param_0, char param_1, const Rope & param_2)
{
  Rope ret;
  append( ret, "mult(", 5);
  append( ret, ' ');
  append( ret, param_0);
  append( ret, ' ');
  append( ret, param_1);
  append( ret, ' ');
  append( ret, param_2);
  append( ret, ' ');
  append( ret, ')');
  return ret;
}


    void out::cyk()
{

}



#ident "$Id: Compiled with gapc gapc $"

